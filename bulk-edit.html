<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Product Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #4a9eff;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .search-section {
            background: #1e1e2e;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .search-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #b0b0b0;
            font-weight: 500;
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 12px;
            background: #2a2a3e;
            border: 2px solid #3a3a4e;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        textarea {
            min-height: 100px;
            font-family: monospace;
        }

        input:focus,
        textarea:focus {
            outline: none;
            border-color: #4a9eff;
        }

        button {
            padding: 12px 30px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
        }

        button:hover {
            background: #3a8eef;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        .btn-save {
            background: #28a745;
            padding: 15px 40px;
            font-size: 18px;
        }

        .btn-save:hover {
            background: #218838;
        }

        .message {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .message.success {
            background: #28a745;
            color: white;
            display: block;
        }

        .message.error {
            background: #dc3545;
            color: white;
            display: block;
        }

        .message.info {
            background: #17a2b8;
            color: white;
            display: block;
        }

        .table-container {
            background: #1e1e2e;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow-x: auto;
            display: none;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: #2a2a3e;
            table-layout: fixed;
        }

        th {
            background: #3a3a4e;
            color: #4a9eff;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            position: relative;
            min-width: 80px;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #4a4a5e;
        }

        th.sortable {
            padding-right: 25px;
        }

        .sort-indicator {
            position: absolute;
            right: 18px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #4a9eff;
            pointer-events: none;
            z-index: 1;
        }

        th.sort-asc .sort-indicator::after {
            content: '▲';
        }

        th.sort-desc .sort-indicator::after {
            content: '▼';
        }

        th.sortable .sort-indicator::after {
            content: '⇅';
            opacity: 0.5;
        }

        th .resizer {
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            user-select: none;
            background: transparent;
            z-index: 20;
            pointer-events: auto;
        }

        th .resizer:hover {
            background: #4a9eff;
        }

        th.resizing .resizer {
            background: #4a9eff;
        }

        td {
            padding: 8px;
            border-bottom: 1px solid #3a3a4e;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
        }

        td.selected {
            background: #2a3a4e;
        }

        .fill-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 8px;
            height: 8px;
            background: #4a9eff;
            cursor: crosshair;
            border: 1px solid #3a8eef;
            border-radius: 2px;
            z-index: 20;
            display: none;
        }

        td.selected .fill-handle {
            display: block;
        }

        td.fill-active {
            background: #3a4a5e;
            border: 2px dashed #4a9eff;
        }

        tr:hover {
            background: #33334e;
        }

        input[type="text"],
        input[type="number"],
        input[type="checkbox"],
        select {
            width: 100%;
            padding: 6px;
            background: #1e1e2e;
            border: 1px solid #3a3a4e;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            transition: background 0.3s, border-color 0.3s;
        }

        input[type="text"].changed,
        input[type="number"].changed {
            background: #2a3a2e;
            border: 2px solid #4a9eff;
            box-shadow: 0 0 5px rgba(74, 158, 255, 0.3);
        }

        input[type="checkbox"].changed {
            outline: 2px solid #4a9eff;
            outline-offset: 2px;
        }

        select option {
            background: #2a2a3e;
            color: #e0e0e0;
            padding: 8px;
        }

        select option:checked {
            background: #4a9eff;
            color: white;
        }

        input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #4a9eff;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a3e;
            border-radius: 6px;
        }

        .stat-item {
            flex: 1;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a9eff;
        }

        .stat-label {
            font-size: 12px;
            color: #b0b0b0;
            margin-top: 5px;
        }

        .column-toggle {
            margin-bottom: 15px;
            padding: 10px;
            background: #2a2a3e;
            border-radius: 6px;
        }

        .column-toggle label {
            display: inline-block;
            margin-right: 15px;
            margin-bottom: 5px;
        }

        .column-toggle input[type="checkbox"] {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bulk Product Editor</h1>

        <div id="message" class="message"></div>

        <div class="search-section">
            <div class="search-options">
                <div class="form-group">
                    <label for="pluInput">Search by PLUs (comma or line separated)</label>
                    <textarea id="pluInput" placeholder="405003, 100001, 100002&#10;Or one per line"></textarea>
                </div>
                <div class="form-group">
                    <label for="categoryInput">Search by Categories</label>
                    <select id="categoryInput" multiple size="5" style="width: 100%; padding: 12px; background: #2a2a3e; border: 2px solid #3a3a4e; border-radius: 6px; color: #e0e0e0; font-size: 14px;">
                        <option value="">Loading categories...</option>
                    </select>
                    <small style="color: #b0b0b0; margin-top: 5px; display: block;">Hold Ctrl (or Cmd on Mac) to select multiple categories</small>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px; display: flex; gap: 15px; justify-content: center;">
                <button type="button" onclick="loadProducts()">Load Products</button>
                <button type="button" onclick="clearSelection()" style="background: #6c757d;">Clear</button>
            </div>
        </div>

        <div id="tableContainer" class="table-container">
            <div class="stats" id="stats">
                <div class="stat-item">
                    <div class="stat-value" id="totalProducts">0</div>
                    <div class="stat-label">Total Products</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="modifiedProducts">0</div>
                    <div class="stat-label">Modified</div>
                </div>
            </div>

            <div class="column-toggle">
                <strong>Show/Hide Columns:</strong><br>
                <label><input type="checkbox" class="col-toggle" data-col="ProductId" checked> Product ID</label>
                <label><input type="checkbox" class="col-toggle" data-col="PLU" checked> PLU</label>
                <label><input type="checkbox" class="col-toggle" data-col="Name" checked> Name</label>
                <label><input type="checkbox" class="col-toggle" data-col="POSDisplay" checked> POS Display</label>
                <label><input type="checkbox" class="col-toggle" data-col="OnlineName"> Online Name</label>
                <label><input type="checkbox" class="col-toggle" data-col="Category" checked> Category</label>
                <label><input type="checkbox" class="col-toggle" data-col="IsActive" checked> Is Active</label>
                <label><input type="checkbox" class="col-toggle" data-col="IsTaxable"> Is Taxable</label>
                <label><input type="checkbox" class="col-toggle" data-col="KMSDisplay" checked> KMS Display</label>
                <label><input type="checkbox" class="col-toggle" data-col="TaxPercentage"> Tax %</label>
            </div>

            <div style="overflow-x: auto;">
                <table id="productsTable">
                    <thead id="tableHead"></thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>

            <div class="actions">
                <button type="button" class="btn-save" onclick="saveAllProducts()">Save All Changes</button>
                <button type="button" onclick="revertChanges()" style="background: #dc3545; padding: 15px 40px; font-size: 18px;">Revert Changes</button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://gyguatapi.xchangefusion.com/api/v3/products';
        const CLIENT_APP_KEY = 'd5f7d501-ffc6-4002-ac7a-f18a8cdd59e4';
        
        let allProducts = [];
        let modifiedProducts = new Set();
        let allCategories = new Set(); // Store all available categories
        let categoryToIdMap = new Map(); // Map Category name to CategoryId
        let originalValues = new Map(); // Store original values for comparison
        let currentSort = { column: null, direction: null }; // Track current sort state
        let columnWidths = new Map(); // Store custom column widths

        function showMessage(text, type) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.className = `message ${type}`;
            setTimeout(() => {
                messageEl.className = 'message';
            }, 5000);
        }

        function getHeaders() {
            return {
                'Accept': 'application/json',
                'ClientAppKey': CLIENT_APP_KEY
            };
        }

        async function loadCategories() {
            try {
                const response = await fetch(API_BASE_URL, {
                    method: 'GET',
                    headers: getHeaders()
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.Items) {
                        // Get unique categories
                        const categories = new Set();
                        data.Items.forEach(product => {
                            if (product.Category) {
                                categories.add(product.Category);
                                allCategories.add(product.Category);
                                // Build category to ID mapping
                                if (product.CategoryId && !categoryToIdMap.has(product.Category)) {
                                    categoryToIdMap.set(product.Category, product.CategoryId);
                                }
                            }
                        });
                        
                        // Sort alphabetically
                        const sortedCategories = Array.from(categories).sort();
                        
                        // Populate dropdown
                        const categorySelect = document.getElementById('categoryInput');
                        categorySelect.innerHTML = '';
                        sortedCategories.forEach(category => {
                            const option = document.createElement('option');
                            option.value = category;
                            option.textContent = category;
                            categorySelect.appendChild(option);
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading categories:', error);
                document.getElementById('categoryInput').innerHTML = '<option value="">Error loading categories</option>';
            }
        }

        function buildCategoryMap() {
            // Build category to ID mapping from all loaded products
            allProducts.forEach(product => {
                if (product.Category && product.CategoryId && !categoryToIdMap.has(product.Category)) {
                    categoryToIdMap.set(product.Category, product.CategoryId);
                }
            });
        }

        function clearSelection() {
            // Clear PLU input
            document.getElementById('pluInput').value = '';
            
            // Clear category selection
            const categorySelect = document.getElementById('categoryInput');
            Array.from(categorySelect.selectedOptions).forEach(option => {
                option.selected = false;
            });
            
            // Clear the table
            allProducts = [];
            modifiedProducts.clear();
            document.getElementById('tableContainer').style.display = 'none';
            
            // Update stats
            updateStats();
            
            showMessage('Selection cleared', 'info');
        }

        async function loadProducts() {
            const pluInput = document.getElementById('pluInput').value.trim();
            const categorySelect = document.getElementById('categoryInput');
            const selectedCategories = Array.from(categorySelect.selectedOptions).map(opt => opt.value).filter(v => v);
            
            if (!pluInput && selectedCategories.length === 0) {
                showMessage('Please enter PLUs or select Categories to search', 'error');
                return;
            }

            showMessage('Loading products...', 'info');
            allProducts = [];
            modifiedProducts.clear();

            try {
                // If PLUs are provided, fetch by PLU
                if (pluInput) {
                    const plus = pluInput.split(/[,\n]/).map(p => p.trim()).filter(p => p);
                    for (const plu of plus) {
                        try {
                            const response = await fetch(`${API_BASE_URL}?PLU=${plu}`, {
                                method: 'GET',
                                headers: getHeaders()
                            });
                            if (response.ok) {
                                const data = await response.json();
                                if (data.Items && data.Items.length > 0) {
                                    allProducts.push(...data.Items);
                                }
                            }
                        } catch (error) {
                            console.error(`Error fetching PLU ${plu}:`, error);
                        }
                    }
                }

                // If categories are provided, fetch all and filter
                if (selectedCategories.length > 0) {
                    const response = await fetch(API_BASE_URL, {
                        method: 'GET',
                        headers: getHeaders()
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.Items) {
                            const filtered = data.Items.filter(p => 
                                selectedCategories.includes(p.Category)
                            );
                            allProducts.push(...filtered);
                        }
                    }
                }

                // Remove duplicates based on ProductId
                const uniqueProducts = [];
                const seenIds = new Set();
                for (const product of allProducts) {
                    if (!seenIds.has(product.ProductId)) {
                        seenIds.add(product.ProductId);
                        uniqueProducts.push(product);
                    }
                }
                allProducts = uniqueProducts;

                if (allProducts.length === 0) {
                    showMessage('No products found', 'error');
                    document.getElementById('tableContainer').style.display = 'none';
                    return;
                }

                showMessage(`Loaded ${allProducts.length} products`, 'success');
                
                // Update allCategories set and categoryToIdMap with categories from loaded products
                allProducts.forEach(product => {
                    if (product.Category) {
                        allCategories.add(product.Category);
                        // Map Category to CategoryId (use the first one found for each category)
                        if (!categoryToIdMap.has(product.Category) && product.CategoryId) {
                            categoryToIdMap.set(product.Category, product.CategoryId);
                        }
                    }
                });
                
                renderTable();
                updateStats();
            } catch (error) {
                showMessage(`Error loading products: ${error.message}`, 'error');
                console.error('Error:', error);
            }
        }

        function renderTable() {
            const tableHead = document.getElementById('tableHead');
            const tableBody = document.getElementById('tableBody');
            
            // Define all columns
            const columns = [
                { key: 'ProductId', label: 'Product ID', type: 'number', readonly: true },
                { key: 'PLU', label: 'PLU', type: 'number', required: true },
                { key: 'Name', label: 'Name', type: 'text', required: true },
                { key: 'POSDisplay', label: 'POS Display', type: 'text', required: true },
                { key: 'KMSDisplay', label: 'KMS Display', type: 'text', required: true },
                { key: 'OnlineName', label: 'Online Name', type: 'text' },
                { key: 'OnlineDescription', label: 'Online Description', type: 'text' },
                { key: 'Description', label: 'Description', type: 'text' },
                { key: 'Category', label: 'Category', type: 'text' },
                { key: 'IsActive', label: 'Is Active', type: 'checkbox' },
                { key: 'IsMandatory', label: 'Is Mandatory', type: 'checkbox' },
                { key: 'Templates', label: 'Templates', type: 'text' },
                { key: 'IsInstruction', label: 'Is Instruction', type: 'checkbox' },
                { key: 'IndentationLevel', label: 'Indentation Level', type: 'number' },
                { key: 'IsTaxable', label: 'Is Taxable', type: 'checkbox' },
                { key: 'Families', label: 'Families', type: 'text' },
                { key: 'LastChangedDate', label: 'Last Changed', type: 'text', readonly: true },
                { key: 'ExternalProductID', label: 'External Product ID', type: 'text' },
                { key: 'ProductInformation', label: 'Product Information', type: 'text' },
                { key: 'ProductNotes', label: 'Product Notes', type: 'text' },
                { key: 'CanBeSold', label: 'Can Be Sold', type: 'checkbox' },
                { key: 'IsRedeemable', label: 'Is Redeemable', type: 'checkbox' },
                { key: 'AssignSequenceNumber', label: 'Assign Sequence Number', type: 'checkbox' },
                { key: 'IsRoyaltyProduct', label: 'Is Royalty Product', type: 'checkbox' },
                { key: 'IsAutoAdd', label: 'Is Auto Add', type: 'checkbox' },
                { key: 'UnitSize', label: 'Unit Size', type: 'number' },
                { key: 'SizeTypeID', label: 'Size Type ID', type: 'number' },
                { key: 'SizeTypeName', label: 'Size Type Name', type: 'text' },
                { key: 'SizeQty', label: 'Size Qty', type: 'number' },
                { key: 'GLCode', label: 'GL Code', type: 'text' },
                { key: 'BackgroundColor', label: 'Background Color', type: 'text' },
                { key: 'Kilojoules', label: 'Kilojoules', type: 'number' },
                { key: 'TaxPercentage', label: 'Tax Percentage', type: 'number' },
                { key: 'HideFromCustomer', label: 'Hide From Customer', type: 'checkbox' },
                { key: 'IsFractional', label: 'Is Fractional', type: 'checkbox' }
            ];

            // Build header with resizers and sort indicators
            tableHead.innerHTML = '<tr>' + columns.map(col => {
                const isReadonly = col.readonly || false;
                const sortClass = (currentSort && currentSort.column === col.key) ? `sort-${currentSort.direction}` : '';
                const sortableClass = isReadonly ? '' : 'sortable';
                const requiredMark = col.required ? '<span style="color: #ff6b6b; margin-left: 3px;">*</span>' : '';
                return `<th data-col="${col.key}" class="${sortableClass} ${sortClass}" style="width: ${getColumnWidth(col.key)}px;">
                    ${col.label}${requiredMark}
                    ${!isReadonly ? '<span class="sort-indicator"></span>' : ''}
                    <div class="resizer"></div>
                </th>`;
            }).join('') + '</tr>';
            
            // Setup column sorting
            setupColumnSorting();
            
            // Setup column resizers
            setupColumnResizers();

            // Build body
            tableBody.innerHTML = '';
            allProducts.forEach((product, index) => {
                const row = document.createElement('tr');
                row.dataset.index = index;
                
                columns.forEach(col => {
                    const cell = document.createElement('td');
                    const value = product[col.key];
                    const colWidth = getColumnWidth(col.key);
                    cell.style.width = colWidth + 'px';
                    cell.dataset.columnKey = col.key;
                    cell.dataset.rowIndex = index;
                    
                    // Add fill handle (only for editable fields)
                    const fillHandle = document.createElement('div');
                    fillHandle.className = 'fill-handle';
                    fillHandle.dataset.columnKey = col.key;
                    fillHandle.dataset.rowIndex = index;
                    
                    if (col.type === 'checkbox') {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = value || false;
                        checkbox.dataset.columnKey = col.key;
                        checkbox.dataset.rowIndex = index;
                        
                        // Store original value for comparison
                        originalValues.set(`${index}_${col.key}`, value || false);
                        
                        checkbox.addEventListener('change', function() {
                            markModified(index, col.key);
                        });
                        checkbox.addEventListener('focus', function() {
                            cell.classList.add('selected');
                        });
                        checkbox.addEventListener('blur', function() {
                            setTimeout(() => {
                                if (!cell.matches(':hover')) {
                                    cell.classList.remove('selected');
                                }
                            }, 100);
                        });
                        cell.appendChild(checkbox);
                        if (!col.readonly) {
                            cell.appendChild(fillHandle);
                        }
                    } else if (col.readonly) {
                        cell.textContent = value || '';
                        cell.style.color = '#888';
                    } else {
                        const input = document.createElement('input');
                        input.type = col.type === 'number' ? 'number' : 'text';
                        if (col.type === 'number' && col.key !== 'PLU') {
                            input.step = col.key.includes('Percentage') || col.key.includes('Size') ? '0.01' : '1';
                        }
                        input.value = formatValue(value, col.key);
                        input.readOnly = col.readonly || false;
                        input.dataset.columnKey = col.key;
                        input.dataset.rowIndex = index;
                        
                        // Store original value for comparison
                        originalValues.set(`${index}_${col.key}`, formatValue(value, col.key));
                        
                        input.addEventListener('input', function() {
                            markModified(index, col.key);
                        });
                        input.addEventListener('focus', function() {
                            cell.classList.add('selected');
                        });
                        input.addEventListener('blur', function() {
                            setTimeout(() => {
                                if (!cell.matches(':hover')) {
                                    cell.classList.remove('selected');
                                }
                            }, 100);
                        });
                        
                        // Special handling for Category field - update CategoryId when Category changes (for internal use)
                        if (col.key === 'Category') {
                            input.addEventListener('input', function() {
                                // CategoryId is handled internally, no UI update needed
                                const rowElement = this.closest('tr');
                                if (rowElement) {
                                    const rowIdx = parseInt(rowElement.dataset.index);
                                    markModified(rowIdx, col.key);
                                }
                            });
                        }
                        
                        
                        // KMSDisplay is required by API - must be at least 3 characters
                        // If left empty, will default to "N/A"
                        if (col.key === 'KMSDisplay') {
                            input.minLength = 3;
                        }
                        cell.appendChild(input);
                        cell.appendChild(fillHandle);
                    }
                    
                    row.appendChild(cell);
                });
                tableBody.appendChild(row);
            });

            // Setup column toggles
            setupColumnToggles();
            
            // Setup fill handle drag functionality
            setupFillHandles();
            
            document.getElementById('tableContainer').style.display = 'block';
        }

        function formatValue(value, key) {
            if (value === null || value === undefined) return '';
            if (Array.isArray(value)) {
                return value.join(',');
            }
            if (typeof value === 'object') {
                return JSON.stringify(value);
            }
            return value.toString();
        }

        function markModified(index, fieldKey = null) {
            modifiedProducts.add(index);
            updateStats();
            
            // Highlight the changed field
            if (fieldKey !== null) {
                const row = document.querySelector(`tr[data-index="${index}"]`);
                if (row) {
                    const input = row.querySelector(`input[data-column-key="${fieldKey}"], input[type="checkbox"][data-column-key="${fieldKey}"]`);
                    if (input) {
                        // Check if value actually changed
                        const originalValue = originalValues.get(`${index}_${fieldKey}`);
                        let currentValue;
                        
                        if (input.type === 'checkbox') {
                            currentValue = input.checked;
                        } else {
                            currentValue = input.value.trim();
                        }
                        
                        if (originalValue !== currentValue) {
                            input.classList.add('changed');
                        } else {
                            input.classList.remove('changed');
                        }
                    }
                }
            }
        }

        function updateStats() {
            document.getElementById('totalProducts').textContent = allProducts.length;
            document.getElementById('modifiedProducts').textContent = modifiedProducts.size;
        }

        function revertChanges() {
            if (modifiedProducts.size === 0) {
                showMessage('No changes to revert', 'info');
                return;
            }

            if (!confirm(`Are you sure you want to revert all changes? This will restore ${modifiedProducts.size} product(s) to their original values.`)) {
                return;
            }

            // Revert each modified product
            modifiedProducts.forEach(index => {
                const row = document.querySelector(`tr[data-index="${index}"]`);
                if (!row) return;

                const product = allProducts[index];
                if (!product) return;

                // Get all inputs and checkboxes in the row
                const inputs = row.querySelectorAll('input[data-column-key]');
                const checkboxes = row.querySelectorAll('input[type="checkbox"][data-column-key]');

                // Restore text/number inputs
                inputs.forEach(input => {
                    const fieldKey = input.dataset.columnKey;
                    const originalValue = originalValues.get(`${index}_${fieldKey}`);
                    
                    if (originalValue !== undefined) {
                        input.value = formatValue(originalValue, fieldKey);
                        input.classList.remove('changed');
                    }
                });

                // Restore checkboxes
                checkboxes.forEach(checkbox => {
                    const fieldKey = checkbox.dataset.columnKey;
                    const originalValue = originalValues.get(`${index}_${fieldKey}`);
                    
                    if (originalValue !== undefined) {
                        checkbox.checked = originalValue;
                        checkbox.classList.remove('changed');
                    }
                });
            });

            // Clear modified products tracking
            modifiedProducts.clear();
            updateStats();
            showMessage('All changes have been reverted', 'success');
        }

        function setupColumnToggles() {
            const toggles = document.querySelectorAll('.col-toggle');
            toggles.forEach(toggle => {
                toggle.addEventListener('change', function() {
                    const col = this.dataset.col;
                    const cells = document.querySelectorAll(`th[data-col="${col}"], td:nth-child(${getColumnIndex(col) + 1})`);
                    cells.forEach(cell => {
                        cell.style.display = this.checked ? '' : 'none';
                    });
                });
            });
        }

        function getColumnIndex(colKey) {
            const headers = Array.from(document.querySelectorAll('th[data-col]'));
            return headers.findIndex(th => th.dataset.col === colKey);
        }

        function setupColumnSorting() {
            // Ensure currentSort is initialized
            if (!currentSort) {
                currentSort = { column: null, direction: null };
            }
            
            const headers = document.querySelectorAll('th.sortable');
            headers.forEach(header => {
                header.addEventListener('click', function(e) {
                    // Don't sort if clicking on the resizer or sort indicator
                    if (e.target.classList.contains('resizer') || 
                        e.target.closest('.resizer') ||
                        e.target.classList.contains('sort-indicator') ||
                        e.target.closest('.sort-indicator')) {
                        return;
                    }
                    
                    // Check if the click is on the right edge (resizer area)
                    const rect = this.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const width = rect.width;
                    if (clickX > width - 10) { // Last 10px is resizer area
                        return;
                    }
                    
                    const colKey = this.dataset.col;
                    
                    // Ensure currentSort is initialized
                    if (!currentSort) {
                        currentSort = { column: null, direction: null };
                    }
                    
                    // Determine sort direction
                    if (currentSort.column === colKey) {
                        // Toggle direction: asc -> desc -> asc
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        // New column, start with ascending
                        currentSort.column = colKey;
                        currentSort.direction = 'asc';
                    }
                    
                    // Sort the products
                    sortProducts(currentSort.column, currentSort.direction);
                    
                    // Re-render table with sorted data
                    renderTable();
                });
            });
        }

        function sortProducts(columnKey, direction) {
            allProducts.sort((a, b) => {
                let aVal = a[columnKey];
                let bVal = b[columnKey];
                
                // Handle null/undefined values
                if (aVal === null || aVal === undefined) aVal = '';
                if (bVal === null || bVal === undefined) bVal = '';
                
                // Handle arrays (convert to string for comparison)
                if (Array.isArray(aVal)) aVal = aVal.join(',');
                if (Array.isArray(bVal)) bVal = bVal.join(',');
                
                // Handle objects (convert to string)
                if (typeof aVal === 'object') aVal = JSON.stringify(aVal);
                if (typeof bVal === 'object') bVal = JSON.stringify(bVal);
                
                // Convert to strings for comparison
                aVal = String(aVal).toLowerCase();
                bVal = String(bVal).toLowerCase();
                
                // Compare
                let comparison = 0;
                if (aVal < bVal) {
                    comparison = -1;
                } else if (aVal > bVal) {
                    comparison = 1;
                }
                
                // Apply direction
                return direction === 'asc' ? comparison : -comparison;
            });
        }

        function setupFillHandles() {
            const handles = document.querySelectorAll('.fill-handle');
            let isDragging = false;
            let startCell = null;
            let startValue = null;
            let startInput = null;

            handles.forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isDragging = true;
                    const cell = this.parentElement;
                    startCell = cell;
                    const rowIdx = parseInt(cell.dataset.rowIndex);
                    const colKey = cell.dataset.columnKey;
                    
                    // Get the input or checkbox value
                    const input = cell.querySelector('input');
                    if (input) {
                        if (input.type === 'checkbox') {
                            startValue = input.checked;
                        } else {
                            startValue = input.value;
                        }
                        startInput = input;
                    }
                    
                    document.body.style.cursor = 'crosshair';
                    document.body.style.userSelect = 'none';
                    
                    const handleMouseMove = (e) => {
                        if (!isDragging) return;
                        
                        // Find the cell under the mouse
                        const target = document.elementFromPoint(e.clientX, e.clientY);
                        const targetCell = target ? target.closest('td[data-column-key]') : null;
                        
                        if (targetCell && targetCell !== startCell) {
                            // Clear previous highlights
                            document.querySelectorAll('td.fill-active').forEach(c => {
                                c.classList.remove('fill-active');
                            });
                            
                            // Highlight cells that will be filled
                            const startRow = parseInt(startCell.dataset.rowIndex);
                            const startCol = getColumnIndex(startCell.dataset.columnKey);
                            const targetRow = parseInt(targetCell.dataset.rowIndex);
                            const targetCol = getColumnIndex(targetCell.dataset.columnKey);
                            
                            const minRow = Math.min(startRow, targetRow);
                            const maxRow = Math.max(startRow, targetRow);
                            const minCol = Math.min(startCol, targetCol);
                            const maxCol = Math.max(startCol, targetCol);
                            
                            // Highlight all cells in the range
                            for (let r = minRow; r <= maxRow; r++) {
                                for (let c = minCol; c <= maxCol; c++) {
                                    const row = document.querySelector(`tr[data-index="${r}"]`);
                                    if (row) {
                                        const cells = row.querySelectorAll('td[data-column-key]');
                                        if (cells[c]) {
                                            cells[c].classList.add('fill-active');
                                        }
                                    }
                                }
                            }
                        }
                    };
                    
                    const handleMouseUp = (e) => {
                        if (!isDragging) return;
                        
                        isDragging = false;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        
                        // Find the target cell
                        const target = document.elementFromPoint(e.clientX, e.clientY);
                        const targetCell = target ? target.closest('td[data-column-key]') : null;
                        
                        if (targetCell && startValue !== null && startInput) {
                            const startRow = parseInt(startCell.dataset.rowIndex);
                            const startCol = getColumnIndex(startCell.dataset.columnKey);
                            const targetRow = parseInt(targetCell.dataset.rowIndex);
                            const targetCol = getColumnIndex(targetCell.dataset.columnKey);
                            
                            const minRow = Math.min(startRow, targetRow);
                            const maxRow = Math.max(startRow, targetRow);
                            const minCol = Math.min(startCol, targetCol);
                            const maxCol = Math.max(startCol, targetCol);
                            
                            // Fill all cells in the range (same column only)
                            for (let r = minRow; r <= maxRow; r++) {
                                const row = document.querySelector(`tr[data-index="${r}"]`);
                                if (row) {
                                    const cell = row.querySelector(`td[data-column-key="${colKey}"]`);
                                    if (cell) {
                                        const input = cell.querySelector('input');
                                        if (input && !input.readOnly) {
                                            if (input.type === 'checkbox') {
                                                input.checked = startValue;
                                            } else {
                                                input.value = startValue;
                                            }
                                            // Trigger input event to mark as modified
                                            input.dispatchEvent(new Event('input', { bubbles: true }));
                                            markModified(r, colKey);
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Clear highlights
                        document.querySelectorAll('td.fill-active').forEach(c => {
                            c.classList.remove('fill-active');
                        });
                        
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };
                    
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });
            });
        }

        function getColumnWidth(colKey) {
            // Check if we have a custom width stored
            if (columnWidths.has(colKey)) {
                return columnWidths.get(colKey);
            }
            
            // Default widths for different column types
            const widths = {
                'ProductId': 100,
                'PLU': 80,
                'Name': 150,
                'POSDisplay': 120,
                'OnlineName': 120,
                'OnlineDescription': 200,
                'Description': 200,
                'Category': 120,
                'IsActive': 80,
                'IsMandatory': 100,
                'Templates': 100,
                'IsInstruction': 110,
                'IndentationLevel': 130,
                'IsTaxable': 90,
                'Families': 100,
                'LastChangedDate': 150,
                'ExternalProductID': 130,
                'ProductInformation': 150,
                'ProductNotes': 150,
                'CanBeSold': 90,
                'IsRedeemable': 110,
                'AssignSequenceNumber': 150,
                'IsRoyaltyProduct': 130,
                'IsAutoAdd': 90,
                'UnitSize': 90,
                'SizeTypeID': 100,
                'SizeTypeName': 120,
                'SizeQty': 90,
                'GLCode': 100,
                'BackgroundColor': 120,
                'KMSDisplay': 120,
                'Kilojoules': 100,
                'TaxPercentage': 120,
                'HideFromCustomer': 130,
                'IsFractional': 110
            };
            const defaultWidth = widths[colKey] || 120;
            // Store the default width so we can track changes
            if (!columnWidths.has(colKey)) {
                columnWidths.set(colKey, defaultWidth);
            }
            return defaultWidth;
        }
        
        function setColumnWidth(colKey, width) {
            columnWidths.set(colKey, width);
        }

        function setupColumnResizers() {
            const headers = document.querySelectorAll('th');
            let currentResizer = null;
            let startX = 0;
            let startWidth = 0;
            let currentHeader = null;

            headers.forEach(header => {
                const resizer = header.querySelector('.resizer');
                if (!resizer) return;

                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent triggering sort on header click
                    currentResizer = resizer;
                    currentHeader = header;
                    startX = e.pageX;
                    startWidth = header.offsetWidth;
                    
                    header.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';

                    const handleMouseMove = (e) => {
                        if (!currentHeader) return;
                        const diff = e.pageX - startX;
                        const newWidth = Math.max(80, startWidth + diff); // Minimum width 80px
                        currentHeader.style.width = newWidth + 'px';
                        
                        // Update all cells in this column
                        const allHeaders = Array.from(document.querySelectorAll('th'));
                        const colIndex = allHeaders.indexOf(currentHeader) + 1;
                        const cells = document.querySelectorAll(`td:nth-child(${colIndex})`);
                        cells.forEach(cell => {
                            cell.style.width = newWidth + 'px';
                        });
                    };

                    const handleMouseUp = () => {
                        if (currentHeader) {
                            // Save the final width
                            const colKey = currentHeader.dataset.col;
                            // Get width from style attribute or computed width
                            let finalWidth = currentHeader.offsetWidth;
                            if (currentHeader.style.width) {
                                const parsedWidth = parseInt(currentHeader.style.width);
                                if (!isNaN(parsedWidth)) {
                                    finalWidth = parsedWidth;
                                }
                            }
                            if (colKey && finalWidth > 0) {
                                setColumnWidth(colKey, finalWidth);
                            }
                            
                            currentHeader.classList.remove('resizing');
                        }
                        currentResizer = null;
                        currentHeader = null;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                    };

                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                });
            });
        }

        function getProductData(rowIndex) {
            const row = document.querySelector(`tr[data-index="${rowIndex}"]`);
            const product = { ...allProducts[rowIndex] };
            // Immediately exclude Templates, Families, DietaryTags, and UniversalTags to prevent foreign key errors
            delete product.Templates;
            delete product.Families;
            delete product.DietaryTags;
            delete product.UniversalTags;
            const cells = row.querySelectorAll('td');
            
            const columns = [
                'ProductId', 'PLU', 'Name', 'POSDisplay', 'KMSDisplay', 'OnlineName', 'OnlineDescription', 'Description',
                'Category', 'IsActive', 'IsMandatory', 'Templates', 'IsInstruction',
                'IndentationLevel', 'IsTaxable', 'Families', 'LastChangedDate', 'ExternalProductID',
                'ProductInformation', 'ProductNotes', 'CanBeSold', 'IsRedeemable', 'AssignSequenceNumber',
                'IsRoyaltyProduct', 'IsAutoAdd', 'UnitSize', 'SizeTypeID', 'SizeTypeName', 'SizeQty',
                'GLCode', 'BackgroundColor', 'Kilojoules', 'TaxPercentage',
                'HideFromCustomer', 'IsFractional'
            ];

            columns.forEach((key, idx) => {
                const cell = cells[idx];
                if (!cell) {
                    console.warn(`Cell not found for column ${key} at index ${idx}`);
                    return;
                }
                if (key === 'IsActive' || key === 'IsMandatory' || key === 'IsInstruction' || 
                    key === 'IsTaxable' || key === 'CanBeSold' || key === 'IsRedeemable' ||
                    key === 'AssignSequenceNumber' || key === 'IsRoyaltyProduct' || key === 'IsAutoAdd' ||
                    key === 'HideFromCustomer' || key === 'IsFractional') {
                    const checkbox = cell.querySelector('input[type="checkbox"]');
                    product[key] = checkbox ? checkbox.checked : false;
                } else if (key === 'ProductId' || key === 'LastChangedDate') {
                    // Read-only fields, keep original
                } else {
                    const input = cell.querySelector('input');
                    if (input) {
                        const value = input.value.trim();
                        if (key === 'PLU') {
                            product[key] = parseInt(value) || product[key];
                        } else if (key === 'IndentationLevel' || key === 'SizeTypeID') {
                            product[key] = value ? parseInt(value) : null;
                        } else if (key === 'UnitSize' || key === 'SizeQty' || key === 'Kilojoules' || key === 'TaxPercentage') {
                            product[key] = value ? parseFloat(value) : null;
                        } else if (key === 'Templates' || key === 'Families') {
                            // Always exclude Templates and Families to avoid foreign key errors
                            // These fields often have invalid IDs that cause FK constraint violations
                            delete product[key];
                        } else {
                            product[key] = value || null;
                        }
                    }
                }
            });

            // Validate required fields
            if (!product.Name || product.Name.trim() === '') {
                throw new Error(`Product PLU ${product.PLU}: Name is required`);
            }
            
            if (!product.POSDisplay || product.POSDisplay.trim() === '') {
                throw new Error(`Product PLU ${product.PLU}: POS Display is required`);
            }
            
            // KMSDisplay is required by the API - must have at least 3 characters
            if (!product.KMSDisplay || product.KMSDisplay.trim().length < 3) {
                throw new Error(`Product PLU ${product.PLU}: KMS Display is required and must be at least 3 characters`);
            }
            
            // Ensure KMSDisplay is trimmed
            product.KMSDisplay = product.KMSDisplay.trim();
            
            // Set CategoryId based on Category (for API, but not shown in UI)
            if (product.Category && categoryToIdMap.has(product.Category)) {
                product.CategoryId = categoryToIdMap.get(product.Category);
            }

            // Validate Category if it was changed
            if (product.Category && allCategories.size > 0 && !allCategories.has(product.Category)) {
                throw new Error(`Product ${product.PLU}: Category "${product.Category}" does not exist. Please use an existing category from the dropdown.`);
            }

            // Validate required fields
            if (!product.Name || product.Name.trim() === '') {
                throw new Error(`Product PLU ${product.PLU}: Name is required`);
            }
            
            if (!product.POSDisplay || product.POSDisplay.trim() === '') {
                throw new Error(`Product PLU ${product.PLU}: POS Display is required`);
            }
            
            // KMSDisplay is required by the API - must have at least 3 characters
            if (!product.KMSDisplay || product.KMSDisplay.trim().length < 3) {
                throw new Error(`Product PLU ${product.PLU}: KMS Display is required and must be at least 3 characters`);
            }
            
            // Ensure KMSDisplay is trimmed
            product.KMSDisplay = product.KMSDisplay.trim();

            // Always exclude Templates, Families, DietaryTags, and UniversalTags to avoid foreign key errors
            // These fields often have invalid IDs that cause FK constraint violations
            delete product.Templates;
            delete product.Families;
            // Exclude DietaryTags and UniversalTags to avoid foreign key constraint errors
            // These often have invalid tag IDs that cause FK constraint violations
            if (product.DietaryTags) {
                delete product.DietaryTags;
            }
            if (product.UniversalTags) {
                delete product.UniversalTags;
            }

            // Remove null values
            Object.keys(product).forEach(key => {
                if (product[key] === null || product[key] === '') {
                    delete product[key];
                }
            });

            return product;
        }

        async function saveAllProducts() {
            if (modifiedProducts.size === 0) {
                showMessage('No products have been modified', 'info');
                return;
            }

            const productsToSave = Array.from(modifiedProducts).map(idx => {
                try {
                    return getProductData(idx);
                } catch (error) {
                    showMessage(error.message, 'error');
                    throw error;
                }
            });

            showMessage(`Saving ${productsToSave.length} products...`, 'info');

            let successCount = 0;
            let errorCount = 0;
            const errors = [];

            for (const product of productsToSave) {
                try {
                    const formBody = Object.keys(product).map(key => {
                        const value = product[key];
                        if (Array.isArray(value)) {
                            return `${key}=${encodeURIComponent(JSON.stringify(value))}`;
                        } else if (typeof value === 'object' && value !== null) {
                            return `${key}=${encodeURIComponent(JSON.stringify(value))}`;
                        } else {
                            return `${key}=${encodeURIComponent(value)}`;
                        }
                    }).join('&');

                    const response = await fetch(API_BASE_URL, {
                        method: 'PUT',
                        headers: {
                            ...getHeaders(),
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: formBody
                    });

                    if (response.ok) {
                        successCount++;
                    } else {
                        const errorText = await response.text();
                        let errorMessage = `Product PLU ${product.PLU} (${product.Name || 'Unknown'}): `;
                        
                        try {
                            const errorJson = JSON.parse(errorText);
                            if (errorJson.Message) {
                                errorMessage += errorJson.Message;
                                
                                // Check for common errors
                                if (errorJson.Message.includes('FOREIGN KEY constraint')) {
                                    if (errorJson.Message.includes('Templates')) {
                                        errorMessage += ' - Templates field has invalid foreign key reference.';
                                    } else if (errorJson.Message.includes('Families') || errorJson.Message.includes('TerminalProductFamily')) {
                                        errorMessage += ' - Families field has invalid foreign key reference. Families are automatically excluded to prevent this error.';
                                    } else if (errorJson.Message.includes('DietaryTags') || errorJson.Message.includes('TerminalDietaryTags')) {
                                        errorMessage += ' - DietaryTags field has invalid foreign key reference. DietaryTags are automatically excluded to prevent this error.';
                                    } else if (errorJson.Message.includes('UniversalTags') || errorJson.Message.includes('TerminalUniversalTags')) {
                                        errorMessage += ' - UniversalTags field has invalid foreign key reference. UniversalTags are automatically excluded to prevent this error.';
                                    } else if (errorJson.Message.includes('Category')) {
                                        errorMessage += ' - Category field has invalid foreign key reference. The category may not exist.';
                                    } else {
                                        errorMessage += ' - Foreign key constraint violation. Check Templates, Families, DietaryTags, UniversalTags, or Category fields.';
                                    }
                                } else if (errorJson.Message.includes('KMSDisplay')) {
                                    errorMessage += ' - KMS Display must be at least 3 characters.';
                                } else if (errorJson.Message.toLowerCase().includes('category')) {
                                    errorMessage += ' - Category validation error. Please use an existing category.';
                                }
                            } else {
                                errorMessage += errorText;
                            }
                        } catch (e) {
                            errorMessage += `HTTP ${response.status}: ${errorText}`;
                        }
                        
                        errors.push(errorMessage);
                        console.error(`Error saving product ${product.PLU}:`, errorText);
                        errorCount++;
                    }
                } catch (error) {
                    const errorMessage = `Product PLU ${product.PLU} (${product.Name || 'Unknown'}): ${error.message}`;
                    errors.push(errorMessage);
                    console.error(`Error saving product ${product.PLU}:`, error);
                    errorCount++;
                }
            }

            if (errorCount === 0) {
                showMessage(`Successfully saved ${successCount} products!`, 'success');
                modifiedProducts.clear();
                updateStats();
            } else {
                let errorMsg = `Saved ${successCount} products, ${errorCount} errors occurred:\n\n`;
                errorMsg += errors.join('\n\n');
                if (errors.length > 5) {
                    errorMsg = `Saved ${successCount} products, ${errorCount} errors occurred.\n\nFirst 5 errors:\n\n` + errors.slice(0, 5).join('\n\n');
                    errorMsg += `\n\n... and ${errors.length - 5} more errors. Check console for details.`;
                }
                showMessage(errorMsg, 'error');
            }
        }

        // Load categories when page loads
        window.addEventListener('DOMContentLoaded', () => {
            loadCategories();
        });
    </script>
</body>
</html>

